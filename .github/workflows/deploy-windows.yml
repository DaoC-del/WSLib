name: Deploy (Windows self-hosted)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  up:
    # 如你的远端 runner 有自定义标签，改成：
    # runs-on: [self-hosted, wsbot-remote]
    runs-on: self-hosted
    defaults:
      run:
        shell: powershell

    # 关键：直接把 Secrets 暴露为环境变量，compose 会读取这些变量
    env:
      ONEBOT_TOKEN: ${{ secrets.ONEBOT_TOKEN }}
      ONEBOT_WS_URL: ws://napcat:3001/?access_token=${{ secrets.ONEBOT_TOKEN }}
      LOG_LEVEL: info

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Diagnostics
        run: |
          Write-Host "User: $(whoami)"
          Write-Host "PSVersion: $($PSVersionTable.PSVersion)"
          docker version
          docker compose version; if ($LASTEXITCODE -ne 0) { docker-compose version }

      - name: Build & Up (NapCat + wsbot)
        run: |
          # 选择 compose 命令：优先 v1 的 docker-compose；否则用 v2 的 docker compose
          $composeCmd = "docker"
          $composeArgsBase = @("compose")
          if (Get-Command docker-compose -ErrorAction SilentlyContinue) {
            $composeCmd = "docker-compose"
            $composeArgsBase = @()
          } else {
            docker compose version | Out-Null
            if ($LASTEXITCODE -ne 0) { throw "Neither 'docker compose' (v2) nor 'docker-compose' (v1) found in PATH" }
          }

          # pull/build/up（命令与参数分开传，避免“docker compose”被当成可执行文件名）
          & $composeCmd @composeArgsBase "pull" 2>$null
          if ($LASTEXITCODE -ne 0) { throw "compose pull failed" }

          & $composeCmd @composeArgsBase "build" "--pull"
          if ($LASTEXITCODE -ne 0) { throw "compose build failed" }

          & $composeCmd @composeArgsBase "up" "-d"
          if ($LASTEXITCODE -ne 0) { throw "compose up failed" }

      - name: Show status
        if: always()
        run: |
          docker ps -a
          (& docker compose logs -n 120 napcat) 2>$null
          (& docker compose logs -n 120 wsbot) 2>$null
